# app/models/schemas.py
from pydantic import BaseModel, Field

class OCRResponse(BaseModel):
    filename: str = Field(..., description="Original filename of the uploaded image.")
    content_type: str = Field(..., description="MIME type of the uploaded file.")
    extracted_text: str = Field(..., description="Text extracted from the image by the Grok model.")
    model_used: str = Field(..., description="The specific Grok model used for OCR.")

class HealthResponse(BaseModel):
    status: str = Field("ok", description="Indicates the health status of the service.")
    app_name: str = Field(..., description="Name of the application.")
    app_version: str = Field(..., description="Version of the application.")

class ErrorDetail(BaseModel):
    detail: str = Field(..., description="A detailed message describing the error.")


# --- Chat Schemas (Similar to Gemini Service) ---
class ChatMessage(BaseModel):
    """Represents a single message in the chat history for Grok."""
    role: str = Field(..., description="Role of the message sender ('user' or 'assistant'). Note: Grok uses 'assistant' for model responses.")
    content: str = Field(..., description="The text content of the message.")
    # Grok API expects a flat list of messages with role/content, not nested 'parts' like Gemini

class ChatRequest(BaseModel):
    """Request model for the Grok chat endpoint."""
    message: str = Field(..., description="The new message from the user.")
    history: list[ChatMessage] = Field([], description="Optional chat history.")
    model_name: str | None = Field(None, description="Optional Grok model override (e.g., 'grok-1.5-flash-latest').")

class ChatResponse(BaseModel):
    """Response model for the Grok chat endpoint."""
    response_text: str = Field(..., description="The text response generated by the Grok model.")
    model_used: str = Field(..., description="The specific Grok model used for the chat response.")